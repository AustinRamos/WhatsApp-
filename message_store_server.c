/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "queue.h"
#include <pthread.h> 
#include <stdlib.h>
#include <stdio.h>
#include <rpc/rpc.h>
#include "message_store.h"
#define MAX_NUM 1000

pthread_mutex_t mutex_msg;
int msg_not_copied = TRUE;
pthread_cond_t cond_msg;
pthread_mutex_t mutexQueue;




bool_t
init_1_svc(void *argp, int *result, struct svc_req *rqstp)
{
		bool_t retval = TRUE;
	//something with result?? have to give it value for stub?
	//initialize the queue here
	
	 *result = queue_destroy();
	printf("Queue has been initialized \n");

if (pthread_mutex_init(&mutexQueue, NULL) != 0) {
        	perror("Mutex Queue error\n");
       	 	
        }

	if (*result!=0){
		printf("queue creation failure \n");
		
		}
		
	retval = TRUE;
	return retval;
}

bool_t
register_1_svc(arguments2 *argp, int *result, struct svc_req *rqstp)
{
	bool_t retval = TRUE;
	
	
		//race condition?
	arguments2 arg = *argp;

	
	printf(" Attempt register %s \n",arg.user);	
	

	struct client_queue newClient; //Create a new client
		strcpy(newClient.client_name, arg.user);
		newClient.status = DISCONNECTED;
		newClient.num_messages = 0;
		newClient.client_port = 0;
	        pthread_mutex_lock(&mutexQueue);//Protect queue
	     
		*result = queue_put(&newClient); //Enqueue the new client
		pthread_mutex_unlock(&mutexQueue);//Unprotect queue
		
printf(" Result =  %i \n",*result);	
		if (*result == 1) { //The user already exists (checked inside queue_put)
			printf("s> REGISTER %s FAIL\n",newClient.client_name);	
			*result = 1; //result uses 1 for fail on client side... dont know why.
		}
		else {
			printf("s> REGISTER %s OK\n",newClient.client_name);
			*result = 0;
		}
	

	return retval;
}

bool_t
unsubscribe_1_svc(arguments2 *argp, int *result, struct svc_req *rqstp)
{
	bool_t retval = TRUE;

//race condition
arguments2 arg = *argp;

	pthread_mutex_lock(&mutexQueue);//Protect queue
		*result = queue_del(arg.user); //Delete the client from the queue. If it doesn't exist is checked inside queue_del
		pthread_mutex_unlock(&mutexQueue);//Unprotect queue
		
		
		if (*result == 0) {
			printf("s> UNREGISTER %s OK\n",arg.user);
		}

	return retval;
}

bool_t
store_1_svc(arguments1 *argp, int *result, struct svc_req *rqstp)
{
		bool_t retval = TRUE;
	
	arguments1 arg = *argp;
	
//going to add the messages to recipients pending messages

	printf("Store: \n Message: %s \n Sender: %s, Recipient: %s \n", arg.message, arg.sender, arg.recipient);
				
			pthread_mutex_lock(&mutexQueue);//Protect queue
			struct client_queue *new_clnt = queue_get(arg.recipient);
			pthread_mutex_unlock(&mutexQueue);//Unprotect queue
			
			//copy all the message to the client(reciever).
			strcpy(new_clnt->list[new_clnt->num_messages].message, arg.message);
				strcpy(new_clnt->list[new_clnt->num_messages].sender, arg.sender);
				strcpy(new_clnt->list[new_clnt->num_messages].receiver, arg.recipient);
			printf("Got to line 123 \n");
			//identifier(unique to this class??) or arg1.message_identifier?
			new_clnt->num_messages++;
			new_clnt->list[new_clnt->num_messages].id = arg.message_identifier; //arg.message_identifier has the value of identifier on the other side + 1/
				printf("s> MESSAGE %d FROM %s TO %s STORED\n", arg.message_identifier, arg.sender, arg.recipient);
			
				
				
				pthread_mutex_lock(&mutexQueue);//Protect queue
				//reciever is the old client name. client is the updated reciever with new values. updating thing.
				//queue_del(arg.recipient); already dequeued above
				*result = queue_put(new_clnt);
				pthread_mutex_unlock(&mutexQueue);//Unprotect queue
				
*result = 0; //success
	
	return retval;
}

bool_t
num_messages_1_svc(arguments2 *argp, int *result, struct svc_req *rqstp)
{
bool_t retval = TRUE;
	arguments2 arg = *argp;
	//protect queue, get client, save # of messages, go to 
	printf("Arg user: %s \n", arg.user);
	pthread_mutex_lock(&mutexQueue);//Protect queue
			struct client_queue *new_clnt = queue_get(arg.user); //queue_get delete the user from the queue, we'll enqueue it again
			*result =  new_clnt->num_messages;
			printf("NUM MESSAGES: %i \n", *result);
			 queue_put (new_clnt);
			pthread_mutex_unlock(&mutexQueue);//Unprotect queue



	return retval;
}

bool_t
get_message_1_svc(arguments2 *argp, char **result, struct svc_req *rqstp)
{
		bool_t retval = TRUE;

arguments2 arg = *argp;
//*** should take it out of the queue

	//Given a user and a message identifier, get the message and the MD5 sent by the user with
//that identifier

//return specific message if user or id does not exist?

int id = arg.message_identifier;

			pthread_mutex_lock(&mutexQueue);//Protect queue
			struct client_queue *new_clnt = queue_get(arg.user); //queue_get delete the user from the queue, we'll enqueue it again
			pthread_mutex_unlock(&mutexQueue);//Unprotect queue

int i;
struct pending_messages msg ;
//locate message
/*
for( i = 0;i<new_clnt->num_messages;i++){
	if (msg.id==id){
		 msg = new_clnt->list[i];
		 break;
		}
	}
	* */
	char * res = malloc(256);
	strcpy(res, new_clnt->list[0].message);
//	printf("MESSAGE get message() : %s \n" , res);
	new_clnt->num_messages--;
	
	//shift list, as message could technically be in the middle.
	
	//have to shift all the messages to the left once we have taken the desired pending message out...
	//hope this is correct
	for(i= 0; i<new_clnt->num_messages;i++){
		 new_clnt->list[i] = new_clnt->list[i+1];
		
		
		}
		

//we have taken client out of the queue. we will take the message out of pending messages, and place client back on queue
pthread_mutex_lock(&mutexQueue);//Protect queue
			queue_put(new_clnt); //queue_get delete the user from the queue, we'll enqueue it again
			pthread_mutex_unlock(&mutexQueue);//Unprotect queue
			
			
//pass message back to client. make sure this is correct with the pointer. possible segmentation fault
*result = res;
//s
//printf("*result  strcpy: %s \n", *result);
		//	strcpy(*result , res);
			//printf("*result after strcpy: %s \n", *result);
	return retval;
}

bool_t
set_status_connected_1_svc(client *argp, int *result, struct svc_req *rqstp)
{
	bool_t retval = TRUE;

/*
 * struct sockaddr_in {
    short            sin_family;   // e.g. AF_INET
    unsigned short   sin_port;     // e.g. htons(3490)
    struct in_addr   sin_addr;     // see struct in_addr, below
    char             sin_zero[8];  // zero this if you want to
};

struct in_addr {
    unsigned long s_addr;  // load with inet_aton()
};
 **/
 //race condition?
 client clnt = *argp;

struct sockaddr_in client_address;

struct in_addr client_in_addr;
 client_in_addr.s_addr = clnt.in_addr_s_addr;
 
client_address.sin_family = clnt.sockaddr_in_sin_family;
client_address.sin_port = 	clnt.sockaddr_in_sin_port;
client_address.sin_addr = client_in_addr;
//client_address.sin_zero = clnt.sockaddr_in_sin_zerp;
strncpy(client_address.sin_zero, clnt.sockaddr_in_sin_zerp, 8);


	//protect queue, get client, save # of messages, go to 
	pthread_mutex_lock(&mutexQueue);//Protect queue
		
	
			
	//is user does not exist exit function and return -2 to indicate not valid user.
	if(check_ifexists(clnt.user)==-1){
		printf("Failure: %s Not registered. \n", clnt.user );
			pthread_mutex_unlock(&mutexQueue);//Unprotect queue	
		*result = -2;
			return retval;
		}
		pthread_mutex_unlock(&mutexQueue);//Unprotect queue
		
	pthread_mutex_lock(&mutexQueue);//Protect queue
		struct client_queue * new_clnt = queue_get(clnt.user); //queue_get delete the user from the queue, we'll enqueue it again
	pthread_mutex_unlock(&mutexQueue);//Unprotect queue
		
			if(new_clnt->status==CONNECTED){
				//user already connected, return message
				printf("Failure: %s already Connected. \n", clnt.user );
				 queue_put (new_clnt);
			pthread_mutex_unlock(&mutexQueue);//Unprotect queue
				*result = -1;
					return retval;
				}
				
				new_clnt->status = CONNECTED;
			
			new_clnt->client_address = client_address;
			new_clnt->client_port = clnt.client_port;
			
			//begin copying data for client_address from clnt argument
			*result =  0;//success
			
			printf("Connect Succesful: %s \n", clnt.user);
			
			pthread_mutex_lock(&mutexQueue);
			printf("CONNECT Num MSG: %i \n", new_clnt->num_messages);
			 queue_put (new_clnt);
			pthread_mutex_unlock(&mutexQueue);//Unprotect queue

	return retval;
}

bool_t
set_status_disconnected_1_svc(arguments2 *argp, int *result, struct svc_req *rqstp)
{
	bool_t retval = TRUE;

	arguments2 arg = *argp;
	//protect queue, get client, save # of messages, go to 
	
	pthread_mutex_lock(&mutexQueue);//Protect queue
	if(check_ifexists(arg.user)==-1){
		pthread_mutex_unlock(&mutexQueue);
		*result = -2;
			return retval;
		}
		
			struct client_queue *clnt = queue_get(arg.user); //queue_get delete the user from the queue, we'll enqueue it again
			pthread_mutex_unlock(&mutexQueue);
			if(clnt->status==DISCONNECTED){
				//user already disconnected, return message
				 queue_put (clnt);
			pthread_mutex_unlock(&mutexQueue);//Unprotect queue
				*result = -1;
					return retval;
				}
			
			memset((char*)&clnt->client_address, 0, sizeof(struct sockaddr_in));
				clnt->client_port = 0;
			clnt->status = DISCONNECTED;
			
				pthread_mutex_lock(&mutexQueue);
			 queue_put (clnt);
			pthread_mutex_unlock(&mutexQueue);//Unprotect queue
*result =  0;//success
printf("Disconnect Succesful \n");

	return retval;
}


//should work just fine
bool_t
get_status_1_svc(arguments2 *argp, char *result, struct svc_req *rqstp)
{
	bool_t retval = TRUE;
//returns 1 for connect, 2 for disconnect, -1 for DNE.
	arguments2 arg = *argp;
	//protect queue, get client, save # of messages, go to 
	//printf("Status of User %s :", arg.user);
	pthread_mutex_lock(&mutexQueue);//Protect queue
	if(check_ifexists(arg.user)==-1){
		pthread_mutex_unlock(&mutexQueue);
		printf("%s status: DNE \n", arg.user);
		*result = -1;
			return retval;
		}
			struct client_queue *clnt = queue_get(arg.user); //queue_get delete the user from the queue, we'll enqueue it again
			*result =  clnt->status;
			printf("%s status: %c \n", arg.user, *result);
			 queue_put (clnt);
			pthread_mutex_unlock(&mutexQueue);//Unprotect queue

	return retval;
}




bool_t
get_reciever_info_1_svc(arguments2 *argp, client *result, struct svc_req *rqstp)
{
	bool_t retval = TRUE;

	 
/*
 * struct sockaddr_in {
    short            sin_family;   // e.g. AF_INET
    unsigned short   sin_port;     // e.g. htons(3490)
    struct in_addr   sin_addr;     // see struct in_addr, below
    char             sin_zero[8];  // zero this if you want to
};

struct in_addr {
    unsigned long s_addr;  // load with inet_aton()
};
 */
 
 //we will be returning reciever
 client reciever;
 //race condition?
arguments2 arg = *argp;
printf("Here we go user: %s \n ", arg.user);
pthread_mutex_lock(&mutexQueue);//Protect queue
		struct client_queue *clnt = queue_get(arg.user); //queue_get delete the user from the queue, we'll enqueue it again
	pthread_mutex_unlock(&mutexQueue);//Unprotect queue
	
	strncpy(reciever.user, arg.user, sizeof(arg.user));
	reciever.client_port = clnt->client_port;
	reciever.sockaddr_in_sin_family = clnt->client_address.sin_family;
	reciever.sockaddr_in_sin_port = clnt->client_address.sin_port;
	strncpy(reciever.sockaddr_in_sin_zerp, clnt->client_address.sin_zero, 8);
	reciever.in_addr_s_addr = clnt->client_address.sin_addr.s_addr;

	 
	 pthread_mutex_lock(&mutexQueue);//Protect queue
		 queue_put(clnt); //queue_get delete the user from the queue, we'll enqueue it again
	pthread_mutex_unlock(&mutexQueue);//Unprotect queue

*result = reciever;
	return retval;
}

bool_t
get_all_messages_1_svc(arguments2 *argp, client_messages *result, struct svc_req *rqstp)
{
	
	result = malloc(sizeof(struct pending_messages)*256);
	bool_t retval = TRUE;

		arguments2 arg = *argp;
	
//going to add the messages to recipients pending messages

				client_messages pending_msgs;
			pthread_mutex_lock(&mutexQueue);//Protect queue
			struct client_queue *new_clnt = queue_get(arg.user);
			pthread_mutex_unlock(&mutexQueue);//Unprotect queue
			
			//cant do this bc noot technically same struct.
			//have to do each field...
			for(int i = 0;i<new_clnt->num_messages;i++){
				//str copy not assign...
				
				strncpy(pending_msgs.list[i].receiver, new_clnt->list[i].receiver, 256);
				strncpy(pending_msgs.list[i].sender, new_clnt->list[i].sender, 256);
				strncpy(pending_msgs.list[i].message, new_clnt->list[i].message, 256);
				pending_msgs.list[i].id = new_clnt->list[i].id;
			printf("Message %s \n", pending_msgs.list[i].message);
				}
				
				//set pending_messages list back to empty
				new_clnt->num_messages = 0;
				
			//	memset(new_clnt->list, '\0', sizeof(new_clnt->list));
			
			
			//set new list = to empty and num_messages to zero.
			
			 pthread_mutex_lock(&mutexQueue);//Protect queue
		 queue_put(new_clnt); //queue_get delete the user from the queue, we'll enqueue it again
	pthread_mutex_unlock(&mutexQueue);//Unprotect queue
//strcpy(*result, pending_msgs);
//(*result).list = pending_msgs.list;
 //memcpy(result->list, pending_msgs.list, sizeof(pending_msgs));
 for(int i = 0;i<256;i++){
				//str copy not assign...
				strncpy(result->list[i].sender, pending_msgs.list[i].sender, 256);
				strncpy(result->list[i].receiver, new_clnt->list[i].receiver, 256);
				strncpy(result->list[i].message, new_clnt->list[i].message, 256);
				result->list[i].id = new_clnt->list[i].id;
				printf("Message %s \n", result->list[i].message);
				}
 //*result = NULL;
			printf("returning retval \n");
	return TRUE;
}

int
message_store_1_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
{
	xdr_free (xdr_result, result);

	/*
	 * Insert additional freeing code here, if needed
	 */

	return 1;
}
