/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <stdio.h>
#include <string.h> 
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h> 
#include <pthread.h> 
#include <errno.h> 
#include "queue.h"
#include <stdlib.h>
#include <rpc/rpc.h>
#include "message_store.h"

#define TRUE 1
#define FALSE 0
#define MAX_NUM 1000
void connection_handler(struct arguments_thread *args);
ssize_t readLine(int fd, char *buffer, size_t n);
pthread_mutex_t mutex_msg;
int msg_not_copied = TRUE;
pthread_cond_t cond_msg;
pthread_mutex_t mutexQueue;
unsigned int identifier = 0;


void
message_store_1(char *host, int i, arguments1 arg1 ,arguments2 arg2,client client_arg, void *resp)
{
	CLIENT *clnt;
	enum clnt_stat retval_1;
	int result_1;
	char *init_1_arg;
	enum clnt_stat retval_2;
	int result_2;
	arguments2  register_1_arg;
	enum clnt_stat retval_3;
	int result_3;
	arguments2  unsubscribe_1_arg;
	enum clnt_stat retval_4;
	int result_4;
	arguments1  store_1_arg;
	enum clnt_stat retval_5;
	int result_5;
	arguments2  num_messages_1_arg;
	enum clnt_stat retval_6;
	char *result_6;
	arguments2  get_message_1_arg;
	enum clnt_stat retval_7;
	int result_7;
	client  set_status_connected_1_arg;
	enum clnt_stat retval_8;
	int result_8;
	arguments2  set_status_disconnected_1_arg;
	enum clnt_stat retval_9;
	char result_9;
	arguments2  get_status_1_arg;
	enum clnt_stat retval_10;
	client result_10;
	arguments2  get_reciever_info_1_arg;
	enum clnt_stat retval_11;
	client_messages result_11;
	arguments2  get_all_messages_1_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, message_store, message_storeVER, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */
if(i==1){
	
	retval_1 = init_1(NULL,&result_1, clnt);

	if (retval_1 != RPC_SUCCESS) {
		*(int *)resp=-1;
		clnt_perror (clnt, "Failed to initialize Queue.");
	}else{
	*(int *)resp=0; //success
}


}
	//printf("result1 %i", result_1);
	if(i==2){
			//mem copy and race condition? Should copy be protected by mutex??
			register_1_arg = arg2;
		//	printf("Sending REGISTER user: %s to Server \n", register_1_arg1.user);
	retval_2 = register_1(&register_1_arg, &result_2, clnt);
	if (retval_2 != RPC_SUCCESS) {
		clnt_perror (clnt, "call failed");
		
	}
	
	//race condition?
	*(int *)resp = result_2;
}
if(i==3){
	//mem copy and race condition? Should copy be protected by mutex??
			unsubscribe_1_arg = arg2;
	
	retval_3 = unsubscribe_1(&unsubscribe_1_arg, &result_3, clnt);
	if (retval_3 != RPC_SUCCESS) {
		clnt_perror (clnt, "call failed");
	}
//race condition?
	*(int *)resp = result_3;	
	
}
if(i==4){
		//race condition
	store_1_arg = arg1;
	
	
	retval_4 = store_1(&store_1_arg, &result_4, clnt);
	
*(int *) resp = result_4;
	//TO DO
	
	
	if (retval_4 != RPC_SUCCESS) {
		clnt_perror (clnt, "call failed");
	}
}
if(i==5){
	
	//race condition:
	num_messages_1_arg = arg2;
	
	retval_5 = num_messages_1(&num_messages_1_arg, &result_5, clnt);
	if (retval_5 != RPC_SUCCESS) {
		clnt_perror (clnt, "call failed");
	}
	
	*(int *) resp = result_5;
	
	
}
if(i==6){
	
	//race condition:
	get_message_1_arg = arg2;
	
	retval_6 = get_message_1(&get_message_1_arg, &result_6, clnt);
	if (retval_6 != RPC_SUCCESS) {
		clnt_perror (clnt, "call failed");
	}
//result_6 prints correctly. test resp
	//string of actual message
	*(char **) resp = result_6;
	//	printf("Message here %s \n", (char *)resp );
	
}

	//NEW ONES
	if(i==7){
		//race condition
	set_status_connected_1_arg	= client_arg;
	
	retval_7 = set_status_connected_1(&set_status_connected_1_arg, &result_7, clnt);
	if (retval_7 != RPC_SUCCESS) {
		clnt_perror (clnt, "call failed");
	}
	//int. 0 for success. -1 for already connected. -2 for not registered, etc.
	*(int *) resp = result_7;
}
if(i==8){
	//will rerun 0 for success. -1 for not connected. -2 for not registered?
	
	//race condition
	set_status_disconnected_1_arg = arg2;
	retval_8 = set_status_disconnected_1(&set_status_disconnected_1_arg, &result_8, clnt);
	if (retval_8 != RPC_SUCCESS) {
		clnt_perror (clnt, "call failed");
	}
	
	* (int *) resp = result_8;
}
if(i==9){
	//status returns CONNECTED or DISCONNECTED enum.
	get_status_1_arg= arg2;
	retval_9 = get_status_1(&get_status_1_arg, &result_9, clnt);
	if (retval_9 != RPC_SUCCESS) {
		clnt_perror (clnt, "call failed");
	}
	
	*(int *)resp = result_9;
	printf("Status %s : %i \n", arg2.user,  result_9);
}
if(i==10){
	get_reciever_info_1_arg = arg2;
	retval_10 = get_reciever_info_1(&get_reciever_info_1_arg, &result_10, clnt);
	if (retval_10 != RPC_SUCCESS) {
		clnt_perror (clnt, "call failed");
	}
	*(client *)resp = result_10;
}
if(i==11){	
	//race condition?
	get_all_messages_1_arg = arg2;
	
	retval_11 = get_all_messages_1(&get_all_messages_1_arg, &result_11, clnt);
	if (retval_11 != RPC_SUCCESS) {
		clnt_perror (clnt, "call failed");
	}
	*(client_messages *) resp = result_11;
	
	
}	
#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}


int
main (int argc, char *argv[])
{
	char *host;

	if (argc < 2) {
		printf ("usage: %s server_host\n", argv[0]);
		exit (1);
	}
	
	host = argv[1];
	
	//**** CODE PASTED FROM ORIGINAL SERVER
	
	int sd, client_sock, c;
	struct sockaddr_in server, client;
	pthread_attr_t t_attr;   //thread atributes
     
	//Create socket
	sd = socket(AF_INET , SOCK_STREAM , 0);
	if (sd == -1) {
        	perror("Could not create socket\n");
		return -1;
	}
	//printf("Socket created\n");
	
	pthread_attr_init(&t_attr);
	pthread_attr_setdetachstate(&t_attr, PTHREAD_CREATE_DETACHED);
	if (pthread_mutex_init(&mutex_msg, NULL) != 0) {
        	perror("Mutex error\n");
        	return -1;
   	}
   //     if (pthread_mutex_init(&mutexQueue, NULL) != 0) {
     //   	perror("Mutex error\n");
      // 	 	return -1;
       // }
     
	//Prepare the sockaddr_in structure
	bzero((char*)&server, sizeof(server));
	server.sin_family = AF_INET;
	server.sin_addr.s_addr = INADDR_ANY;

	//Check if number of arguments is valid and if the port is a valid one. The port is argv[1].
	if (argc == 3) {
		//atoi function to obtain the int value of the port that is a string
		if (atoi(argv[2]) <= 0 || atoi(argv[2]) > 65535) {
			printf("The port is not a valid one \n");
			return -1;
		}
		//htons converts from host byte order to network byte order
		server.sin_port = htons( atoi(argv[2]) );
	}
	else {
		printf("Number of arguments not valid. Please pass a port number\n");
		return -1;
	}
     	//Bind to assign an address to the socket
	if (bind(sd,(struct sockaddr *)&server , sizeof(server)) < 0) {
		perror("bind failed. Error");
        	return -1;
    	}
    	//printf("bind done\n");
      
      //send request to server to initialize the queue
      struct arguments1 arg1;
      struct arguments2 arg2;
      
      struct client client_args;
      
      int * resp =  malloc(sizeof(int));
      printf("Sending init to RPC \n");
      
      //upon queue init failure do something like exit?
	message_store_1(host,1, arg1, arg2, client_args, (void *)resp);
    	//Listen for attendig petitions from the client
    	printf("Listening for java client \n");
    	
    	listen(sd, 10);
	//inet_ntoa function for converting the Internet host address in a string in decimal notation
	printf("s> init server %s:%d\n", inet_ntoa(server.sin_addr), atoi(argv[1]));
     
    	//Accept and incoming connection
    	//printf("Waiting for incoming connections...\n");
    	c = sizeof(client);
    	pthread_t thid;
     
    	//accept connection from an incoming client
    	while(1) {
		client_sock = accept(sd, (struct sockaddr *)&client, (socklen_t*)&c);
		if (client_sock == -1) {
			perror("Error accepting conection");
			return -1;
		}
   		//printf("Connection accepted\n");

		struct arguments_thread args;
		args.client_sock = client_sock;
		args.client_address = client;
		args.host = host;
				
int op = -1;
    		if (pthread_create(&thid , &t_attr ,(void *)&connection_handler , &args) != 0) {
            		perror("could not create thread");
            		return 1;
		}
	
		pthread_mutex_lock(&mutex_msg);
		while (msg_not_copied)
			pthread_cond_wait(&cond_msg, &mutex_msg);
		msg_not_copied = TRUE;
		pthread_mutex_unlock(&mutex_msg);
    	}
	//CODE PASTED FROM ORIGINAL SERVER SET UP SOCKET CONNECTION
	printf("Ready to recieve messages from client \n");
	
	
	
exit (0);
}


void connection_handler(struct arguments_thread *args) {
	struct arguments_thread args_local;
	//memcpy((char *)&args_local, (char *)args, sizeof(struct arguments_thread));
	
	//Thread copies message to local message
    	pthread_mutex_lock(&mutex_msg);

     memcpy((char *)&args_local, (char *)args, sizeof(struct arguments_thread));
	//Wake up server
    	msg_not_copied = FALSE;  // FALSE = 0 

    	pthread_cond_signal(&cond_msg);

    	pthread_mutex_unlock(&mutex_msg);

	char res, res2; //result to send to the client (0,1,2 or 3)
	char operation [MAXMESSAGE];
	char username [MAXMESSAGE];
	char port [6];
	char sender [MAXMESSAGE];
	char receiver [MAXMESSAGE];
	char message [MAXMESSAGE];
	
	//Read operation that the client wants to perform
	if (readLine(args_local.client_sock, operation, MAXMESSAGE) == -1){
		perror("Error in readLine\n");
		return;
	}

	//Register
	if ((strcmp(operation,"REGISTER") == 0)){
		if (readLine(args_local.client_sock, username, MAXMESSAGE) == -1) {
			perror("Error in readLine\n");
			return;
		}
		printf("Host: %s \n", args_local.host);  
		
		//passing dummy structs even if not needed... don't want to change the structure of the 
		struct arguments1 arg1;
		struct arguments2 arg2 ;
		client clnt;
		strcpy(arg2.user, username);
		//dummy value - message id not relevant for this field.
		arg2.message_identifier = -1;
		  int * resp =  malloc(sizeof(int));
		  printf("Calling msg store register for %s \n", username);
		  
		message_store_1 (args_local.host,2, arg1, arg2, clnt, (void *)resp);
		printf("Message Store done \n");
		
		
		if (send(args_local.client_sock, resp, sizeof(char), 0) == -1) {
			perror("Error sending to client\n");
			return;
		}

		if (*resp == 1) { //The user already exists (checked inside queue_put)
			printf("s> REGISTER %s FAIL\n",arg2.user);	
		}
		else {
			printf("s> REGISTER %s OK\n",arg2.user);
		}
	
		 
	}
	
     	// UNREGISTER 
   	else if ((strcmp(operation,"UNREGISTER") == 0)) {	
		
		if (readLine(args_local.client_sock, username, MAXMESSAGE) == -1){
			perror("Error in readLine\n");
			return;
		}
		struct arguments1 arg1;
		struct arguments2 arg2;
		client clnt;
		int * resp = malloc(sizeof(int));
		strcpy(arg2.user, username);
		//dummy value - message id not relevant for this field.
		arg2.message_identifier = -1;
		message_store_1 (args_local.host,3, arg1, arg2,clnt ,(void * )resp);
		
		if (send(args_local.client_sock, resp, sizeof(char), 0) == -1) {
			perror("Error sending to client\n");
			return;
		}
		
		if (*resp == 0) {
			printf("s> UNREGISTER %s OK\n",username);
		}
	}	

	// CONNECT 
	else if ((strcmp(operation,"CONNECT") == 0)) {
		if (readLine(args_local.client_sock, username, MAXMESSAGE) == -1){
			perror("Error in readLine\n");
			return;
		}
		if (readLine(args_local.client_sock, port, MAXMESSAGE) == -1){
			perror("Error in readLine\n");
			return;
		}
		
		//set up arguments for message_store_1.
		
		struct arguments1 arg1;
		struct arguments2 arg2;
		client client_info_rpc;
		int * resp = malloc(sizeof(int));
	
	
		
		// INET socket address struct transfer. confusing, but only way i could get it working and stored on RPC side
		struct sockaddr_in client_address;

	strcpy(client_info_rpc.user, username);
 
	client_info_rpc.client_port = atoi(port);
 client_info_rpc.sockaddr_in_sin_family = args_local.client_address.sin_family ;
 client_info_rpc.sockaddr_in_sin_port = args_local.client_address.sin_port ;
  client_info_rpc.in_addr_s_addr = args_local.client_address.sin_addr.s_addr;
 
strncpy(client_info_rpc.sockaddr_in_sin_zerp, args_local.client_address.sin_zero , 8);
		
			
		message_store_1(args_local.host,7, arg1, arg2,client_info_rpc ,(void * )resp);
		
		//check if user exists. (on connect server side i will check if_exists(user) and send a particular error number if not. -1
		if(*resp==-2){
			//else send res with the error 1 that means that the user doesn't exist
			res = 1;
			if (send(args_local.client_sock, &res, sizeof(char), 0) == -1) {
				perror("Error sending to client\n");
				return;
			}
			printf("s> CONNECT %s FAIL. User does not exist. \n",username);	
			}
			//user is already connected
			if(*resp==-1){
				res = 2;
				if (send(args_local.client_sock, &res, sizeof(char), 0) == -1) {
					perror("Error sending to client\n");
					return;
				}
				printf("s> CONNECT %s FAIL , user is already connected. \n",username);
				}
		
		//now we notify client of succesful connection.  0 = success.
		if(*resp==0){
			printf("Connect Succesful: %s \n", username);
			res = 0;
			if (send(args_local.client_sock, &res, sizeof(char), 0) == -1){
					perror("Error sending to client\n");
					return;
				}
			
			}
			printf("PENDING MESSAGES: \n");
		//now we get pending messages.
		
		client_messages * msgs= malloc(sizeof(struct pending_messages)*256);
		
		//will have to get pending messages. for now just simple connect.
		//get all messages.
		int * num_messages = malloc(sizeof(int));
		
		//arg2 still has name of the user connecting. will get num of messages pending
		strcpy(arg2.user, username);
		message_store_1(args_local.host,5, arg1, arg2,client_info_rpc ,(void * )num_messages);
		printf("NUM MESSAGES for %s : %i \n", arg2.user,*num_messages);
		while(*num_messages>0){ //only pring messages array if it contains more than 1 pending_msg
		char ** responsemsg = malloc(256);
		strcpy(arg2.user, username);
		message_store_1(args_local.host,6, arg1, arg2,client_info_rpc ,(void * )responsemsg);
		printf("Message: %s \n", *responsemsg);
		
		message_store_1(args_local.host,5, arg1, arg2,client_info_rpc ,(void * )num_messages);
		
		//send messages one by one.
	//get client info.
		client * reciever_info = malloc(sizeof(struct client));
			
			//arg2.user still has reciever.
			message_store_1(args_local.host,10, arg1, arg2,client_info_rpc ,(void * )reciever_info);
			
			int sd = socket(AF_INET, SOCK_STREAM, 0); //Create the socket
               			if (sd == -1) {
        				perror("Could not create socket\n");
					return;
				}
			
			//connect to recipient( info retrieved from RPC server).
			struct sockaddr_in addr;
				bzero((char*)&addr, sizeof(addr));
                		addr.sin_family = AF_INET;
                		addr.sin_port = htons(reciever_info->client_port);
               			addr.sin_addr.s_addr = reciever_info->in_addr_s_addr;
                		
                		
                		//now connect to reciever client:
                		if (connect(sd, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
					//error connecting, mark client disconnected.
					message_store_1(args_local.host,8, arg1, arg2,client_info_rpc ,(void * )resp);
                    			perror("connect failed. Error\n");    			
                    			return;
                		}
                		//here is actual sending of message between 2 connected clients. protocol same as it was in part 1.
                		res = 0;
                		if (send(args_local.client_sock, &res, sizeof(char), 0) < 0) {
                  	 		perror("Error sending message\n");
                  			return;
              			}
              			char msg_id[MAXMESSAGE];
						sprintf (msg_id, "%d", identifier);
						if (send(args_local.client_sock, &msg_id, strlen(msg_id)+1, 0) < 0) {					
						perror("Error sending message\n");
						return;
						}
						char send_message[MAXMESSAGE];
						strcpy(send_message, "SEND_MESSAGE");
						if (send(sd, &send_message, strlen(send_message)+1, 0) < 0) {
						perror("Error sending message\n");
						return;
						}
						if (send(sd, &sender, strlen(sender)+1, 0) < 0) {
						perror("Error sending message\n");
						return;
						}
						if (send(sd, &msg_id, strlen(msg_id)+1, 0) < 0) {					
						perror("Error sending message\n");
						return;
						}
						strcpy(message , *responsemsg);
						if (send(sd, &message, strlen(message)+1, 0) < 0) {
						perror("Error sending message\n");
						return;
						}
                		printf("s> SEND MESSAGE %d FROM %s TO %s\n", identifier, sender, receiver);
						identifier++;
						close(sd);
		
		//end while num_messsages>0
		}
		/*
			
				//RECEIVE THE PENDING MESSAGES
				while (client->num_messages > 0) {
					int sd = socket(AF_INET, SOCK_STREAM, 0);
					if (sd == -1) {
						perror("Could not create socket\n");
						return;
					}
					struct sockaddr_in addr;
					bzero((char*)&addr, sizeof(addr));
                			addr.sin_family = AF_INET;
                			addr.sin_port = htons(client->client_port);
               				addr.sin_addr.s_addr = client->client_address.sin_addr.s_addr;
                		
                			// Connect to the receiver
                			if (connect(sd, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
						client->status = DISCONNECTED;
						pthread_mutex_lock(&mutexQueue);//Protect queue
						queue_del(username);
						res = queue_put(client);
						pthread_mutex_unlock(&mutexQueue);//Unprotect queue
                    				perror("connect failed. Error\n");    			
                    				return;
                			}
					char send_message[MAXMESSAGE];
                        		strcpy(send_message, "SEND_MESSAGE");
                       			if (send(sd, &send_message, strlen(send_message)+1, 0) == -1){
                         		   	perror("Error sending.\n");
                         		   	return;
                       			}	
					if (send(sd, &client->list[client->num_messages-1].sender, strlen(client->list[client->num_messages-1].sender)+1, 0) == -1){
                         		   	perror("Error sending.\n");
                         		   	return;
                       			}
					char msg_id[MAXMESSAGE];
                        		sprintf(msg_id, "%d", client->list[client->num_messages-1].id);
                      			if (send(sd, &msg_id, strlen(msg_id)+1, 0) == -1) {
                         		   	perror("Error sending.\n");
                         		   	return;
                        		}
					char msg[MAXMESSAGE];
					strcpy(msg, client->list[client->num_messages-1].message);
                        		if (send(sd, &msg, strlen(msg)+1, 0) == -1) {
                         		   	perror("Error sending.\n");
                         		   	return;
                        		}
                       			close(sd);
                        		printf("s> SEND MESSAGE %d FROM %s TO %s\n", client->list[client->num_messages-1].id, client->list[client->num_messages-1].sender, client->list[client->num_messages-1].receiver);
                        		client->num_messages--;
					pthread_mutex_lock(&mutexQueue);//Protect queue
					queue_del(username);
					queue_put(client);
					pthread_mutex_unlock(&mutexQueue);//Unprotect queue
                   		}

			}
			else {  //User already connected (status == CONNECTED)
				pthread_mutex_lock(&mutexQueue);//Protect queue
				queue_put(client);//I enqueue the element because we don't want to delete it, just to get the values
				pthread_mutex_unlock(&mutexQueue);//Unprotect queue
				res = 2;
				if (send(args_local.client_sock, &res, sizeof(char), 0) == -1) {
					perror("Error sending to client\n");
					return;
				}
				printf("s> CONNECT %s FAIL\n",username);
			}
		}
		else {  //else send res with the error 1 that means that the user doesn't exist
			res = 1;
			if (send(args_local.client_sock, &res, sizeof(char), 0) == -1) {
				perror("Error sending to client\n");
				return;
			}
			printf("s> CONNECT %s FAIL\n",username);	
		}		
		
		*/
	}

	// DISCONNECT 
	else if ((strcmp(operation,"DISCONNECT") == 0)) {
		if (readLine(args_local.client_sock, username, MAXMESSAGE) == -1) {
			perror("Error in readLine\n");
			return;
		}
		
			struct arguments1 arg1;
		struct arguments2 arg2;
		client client_info_rpc;
		int * resp = malloc(sizeof(int));
		
			strcpy(arg2.user, username);
			
			
			message_store_1(args_local.host,8, arg1, arg2,client_info_rpc ,(void * )resp);
		
		//check if user exists. (on connect server side i will check if_exists(user) and send a particular error number if not. -1
		if(*resp==-2){
			//else send res with the error 1 that means that the user doesn't exist
			res = 1;
			if (send(args_local.client_sock, &res, sizeof(char), 0) == -1) {
				perror("Error sending to client\n");
				return;
			}
			printf("s> DISCONNECT %s FAIL. User does not exist. \n",username);	
			}
			//user is already connected
			if(*resp==-1){
				res = 2;
				if (send(args_local.client_sock, &res, sizeof(char), 0) == -1) {
					perror("Error sending to client\n");
					return;
				}
				printf("s> DISCONNECT %s FAIL , user is not currently connected. \n",username);
				}
		
		//now we notify client of succesful connection.  0 = success.
		if(*resp==0){
			printf("Connect Succesful: %s \n", username);
			res = 0;
			if (send(args_local.client_sock, &res, sizeof(char), 0) == -1){
					perror("Error sending to client\n");
					return;
				}
			
			}
			printf("Disconnect Succesful \n");
		
		
	}

	// SEND 
	else if ((strcmp(operation,"SEND") == 0)) {
		if (readLine(args_local.client_sock, sender, MAXMESSAGE) == -1) {
			perror("Error in readLine\n");
			return;
		}

		if (readLine(args_local.client_sock, receiver, MAXMESSAGE) == -1) {
			perror("Error in readLine\n");
			return;
		}
		
		if (readLine(args_local.client_sock, message, MAXMESSAGE) == -1) {
			perror("Error in readLine\n");
			return;
		}
		
		struct arguments1 arg1;
		struct arguments2 arg2;
		client client_info_rpc;
		int * resp = malloc(sizeof(int));
		int * resp2 = malloc(sizeof(int));
			
		
		
		//will follow procedure from original server.
		//first see if either sender or reciever does not exist.
		strcpy(arg2.user, sender);
		printf("Getting status of %s \n", arg2.user);
				message_store_1(args_local.host,9, arg1, arg2,client_info_rpc ,(void * )resp);
				strcpy(arg2.user, receiver);
				printf("Getting status of %s \n", arg2.user);
				message_store_1(args_local.host,9, arg1, arg2,client_info_rpc ,(void * )resp2);
				
				if (*resp == -1 || *resp2 == -1) { //one of them does no exist.
					
		char response;
		if (*resp == -1 ){ //this was working when it was 'res'... maybe should not hav ebeen though...
			response = 2; //send code 2 for no sender exist(or connected?).
			}else{//send code 1 for receiver not exist/connected
				response = 1;
				}
				if (send(args_local.client_sock, &response, sizeof(char), 0) == -1) {
				perror("Error sending to client\n");
				return;
			}
			printf("s> SEND FAIL\n");	
	}	else { //If both exist
		
	//if client is connected:
		//create the socket
		//connect to the reciever
		if(*resp2==CONNECTED){ //if reciever is connected:
			client * reciever_info = malloc(sizeof(struct client));
			
			//arg2.user still has reciever.
			message_store_1(args_local.host,10, arg1, arg2,client_info_rpc ,(void * )reciever_info);
			
			int sd = socket(AF_INET, SOCK_STREAM, 0); //Create the socket
               			if (sd == -1) {
        				perror("Could not create socket\n");
					return;
				}
			
			//connect to recipient( info retrieved from RPC server).
			struct sockaddr_in addr;
				bzero((char*)&addr, sizeof(addr));
                		addr.sin_family = AF_INET;
                		addr.sin_port = htons(reciever_info->client_port);
               			addr.sin_addr.s_addr = reciever_info->in_addr_s_addr;
                		
                		
                		//now connect to reciever client:
                		if (connect(sd, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
					//error connecting, mark client disconnected.
					message_store_1(args_local.host,8, arg1, arg2,client_info_rpc ,(void * )resp);
                    			perror("connect failed. Error\n");    			
                    			return;
                		}
                		//here is actual sending of message between 2 connected clients. protocol same as it was in part 1.
                		res = 0;
                		if (send(args_local.client_sock, &res, sizeof(char), 0) < 0) {
                  	 		perror("Error sending message\n");
                  			return;
              			}
              			char msg_id[MAXMESSAGE];
						sprintf (msg_id, "%d", identifier);
						if (send(args_local.client_sock, &msg_id, strlen(msg_id)+1, 0) < 0) {					
						perror("Error sending message\n");
						return;
						}
						char send_message[MAXMESSAGE];
						strcpy(send_message, "SEND_MESSAGE");
						if (send(sd, &send_message, strlen(send_message)+1, 0) < 0) {
						perror("Error sending message\n");
						return;
						}
						if (send(sd, &sender, strlen(sender)+1, 0) < 0) {
						perror("Error sending message\n");
						return;
						}
						if (send(sd, &msg_id, strlen(msg_id)+1, 0) < 0) {					
						perror("Error sending message\n");
						return;
						}
						if (send(sd, &message, strlen(message)+1, 0) < 0) {
						perror("Error sending message\n");
						return;
						}
                		printf("s> SEND MESSAGE %d FROM %s TO %s\n", identifier, sender, receiver);
						identifier++;
						close(sd);
                		
			}
			else{//reciever is not connected.
				//store the message. prepare message struct to send to rpc server.
				strcpy(arg1.message, message);
				strcpy(arg1.sender, sender);
				strcpy(arg1.recipient, receiver);
			//	strcpy(arg1.filename, filename); //filename
			arg1.message_identifier = identifier + 1;
				message_store_1 (args_local.host,4, arg1, arg2, client_info_rpc, (void *)resp);
				
				
				printf("s> MESSAGE %d FROM %s TO %s STORED\n", identifier, sender, receiver);
				identifier++;
				
				//tell sender that message has been sent/stored.
					res = 0;
                		if (send(args_local.client_sock, &res, sizeof(char), 0) < 0) {
                  	 		perror("Error sending message\n");
                  			return;
              			}
				char msg_id[MAXMESSAGE];
			        sprintf (msg_id, "%d", identifier);
				if (send(args_local.client_sock, &msg_id, strlen(msg_id)+1, 0) < 0) {					
					perror("Error sending message\n");
					return;
				}	
				
				}
	
	
	
	
	
	//********
		//Now to send a message to "sender" client to acknowledge message stored/sent
	client * sender_info = malloc(sizeof(struct client));
			
			//give arg2 from above the value of client.
			printf("SENDER: %s \n", sender);
			strncpy(arg2.user ,sender,30);
			message_store_1(args_local.host,10, arg1, arg2,client_info_rpc ,(void * )sender_info);
			
	if(*resp==CONNECTED){//if sender is connected, create the socket. Not really sure what this is for.
		printf("Line 813 \n");
		int sd = socket(AF_INET, SOCK_STREAM, 0); //Create the socket
               			if (sd == -1) {
        				perror("Could not create socket\n");
					return;
				}
		
			struct sockaddr_in addr;
				bzero((char*)&addr, sizeof(addr));
                		addr.sin_family = AF_INET;
                		addr.sin_port = htons(sender_info->client_port);
               			addr.sin_addr.s_addr = sender_info->in_addr_s_addr;
               		//	addr.sin_family = AF_INET;
                		//addr.sin_port = htons(args_local.client_address.sin_port);
               			//addr.sin_addr.s_addr = args_local.client_address.sin_addr.s_addr;
               			
				// Connect to the sender
                		if (connect(sd, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
					//error connecting, mark client disconnected.
					strncpy(arg2.user,sender,30);
					
					message_store_1(args_local.host,8, arg1, arg2,client_info_rpc ,(void * )resp);
                  			perror("connect failed. Error\n");    			
                    			return;
                		}
                		printf("line 836 \n");
				char sender_ack[MAXMESSAGE];
				strcpy(sender_ack, "SEND_MESS_ACK");
                		if (send(sd, &sender_ack, strlen(sender_ack)+1, 0) < 0) {
                   			perror("Error sending message to the sender\n");
               				return;
              			}
				char msg_id[MAXMESSAGE];
               	 		sprintf (msg_id, "%d", identifier);
               			if (send(sd, &msg_id, strlen(msg_id)+1, 0) == -1) {
                   			perror("Error when sending the return value to the client.");
                  			return;
              			}
				close(sd);
		}

	
}
		
		close(args_local.client_sock);	
		
		
		
	}


   	pthread_exit(NULL);
   	
} 


ssize_t readLine(int sd, char *buffer, size_t n) {

    ssize_t numRead;  /* num of bytes fetched by last read() */
    size_t totRead;	  /* total bytes read so far */
    char *buf;
    char ch;

    if (n <= 0 || buffer == NULL) {
        errno = EINVAL;
        return -1;
    }

    buf = buffer;
    totRead = 0;

    for (;;) {
        numRead = read(sd, &ch, 1);	/* read a byte */

        if (numRead == -1) {
            if (errno == EINTR)	/* interrupted -> restart read() */
                continue;
            else
                return -1;		/* some other error */
        } else if (numRead == 0) {	/* EOF */
            if (totRead == 0)	/* no byres read; return 0 */
                return 0;
            else
                break;
        } else {			/* numRead must be 1 if we get here*/
            if (ch == '\n')
                break;
            if (ch == '\0')
                break;
            if (totRead < n - 1) {		/* discard > (n-1) bytes */
                totRead++;
                *buf++ = ch;
            }
        }
    }

    *buf = '\0';
    return totRead;
}

